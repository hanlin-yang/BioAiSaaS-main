# BioAiSaaS Production Architecture

## Overview

BioAiSaaS Production Edition adopts an **Agent-First + MCP + Multi-Agent Orchestration** three-tier architecture with Supabase as the user and billing hub. The frontend communicates directly with agents via MCP, the backend evolves into an intelligent agent coordination layer, and payment/auth systems are deeply integrated with agent task metering.

---

## Architecture Diagram

```
┌─────────────────────────────────────────────────────────────┐
│                      Frontend Layer                          │
│              (Agent-First UI + MCP Client)                   │
│                                                               │
│  • Dynamic UI generated by Agent inference                   │
│  • MCP Protocol for Agent communication                      │
│  • Chain-of-thought visualization                            │
│  • Built with Lovable/Next.js/React                          │
└────────────┬────────────────────────────────────────────────┘
             │ MCP Protocol (JSON-RPC 2.0)
             ▼
┌─────────────────────────────────────────────────────────────┐
│                   Backend Orchestration Layer                │
│              (Multi-Agent Coordinator + MCP Server)          │
│                                                               │
│  • Multi-Agent Swarm orchestration                           │
│  • MCP Server exposing tools/resources                       │
│  • Task routing & handoff management                         │
│  • Python sandbox execution environment                      │
│  • Task metering & logging                                   │
└────────────┬────────────────────────────────────────────────┘
             │
             ├──────────► Supabase (PostgreSQL + pgvector)
             │            • User accounts & auth
             │            • Project management
             │            • Agent run logs
             │            • Payment records
             │            • Vector search index
             │
             └──────────► Agent Tools Layer
                         • No-database architecture
                         • File system & external APIs
                         • Exposed as MCP tools
```

---

## Core Components

### 1. Frontend: Agent-First Design + MCP

#### Agent-First UI Principles
- **Dynamic Interface Generation**: UI components are generated based on Agent's JSON schema responses
- **Automatic Panel Management**: Non-critical steps are collapsed into a timeline view
- **Three-layer Information Display**:
  1. User input
  2. Agent reasoning summary (safe chain-of-thought)
  3. Execution trace visualization (tool calls + handoff records)

#### MCP Integration
- Frontend acts as **MCP client/host**
- Connects to backend MCP server via WebSocket/HTTP SSE
- Key MCP tools exposed:
  - `bio_agent.run_task`: Execute single task
  - `bio_agent.stream_trace`: Stream thinking chain
  - `billing.get_quote`: Estimate task cost

#### Implementation with Lovable
- Use Lovable to generate React/Next.js frontend
- Key components:
  - `AgentLayout`: Conversation area + dynamic panels + task/cost sidebar
  - MCP client SDK (WebSocket/SSE based)
  - Agent UI Engine for dynamic component rendering

### 2. Backend: Intelligent Agent Coordination Layer

#### Responsibilities
- **Multi-Agent Management**: Manage research, code, eval, synthesis agents
- **MCP Server**: Expose agents and tools as MCP tools
- **Swarm Orchestration**: Decompose tasks into multi-agent flows
- **Event Logging**: Write execution events for billing

#### Multi-Agent / Swarm Pattern
- Define roles: `planner`, `retriever`, `coder`, `evaluator`, `reporter`
- Use Swarm or LangGraph-Swarm style handoffs:
  ```
  planner → retriever → coder → evaluator → reporter
  ```
- State machine/graph management:
  - Nodes: Agent invocations
  - Edges: Handoff rules (based on task type, retry logic)

#### Python Sandbox Execution
- **Secure Sandbox**: Docker containers or seccomp/firejail
- **Resource Constraints**:
  - Read-only data volumes
  - Whitelisted network access (public bio databases only)
  - Short-lived per-task instances
  - Timeout and resource limits
- **MCP Tool Exposure**: `sandbox.run_python(code, requirements, input_files)`

### 3. Database: Supabase (PostgreSQL + pgvector)

#### Hybrid Architecture
**Relational Tables**:
- `users`: User info, auth methods (email/WeChat openid)
- `projects`: Research tasks/projects
- `agent_runs`: Agent execution logs (status, duration, token usage)
- `payments`: Payment records, channels, reconciliation
- `pricing_plans`: Pricing strategies (token-based/outcome-based)

**Vector Tables**:
- `documents`: User private document embeddings (multi-tenant isolated)
- `know_how_index`: Know-How Library vector index

#### Multi-User Support
- Supabase Auth for email login
- Custom WeChat OAuth integration
- All agent calls require `user_id` and `project_id` for metering

### 4. AI Agent Tools: No-Database Architecture

#### Design Principles
- Tools only access:
  - Local filesystem (sandbox-mounted user/project workspace)
  - External APIs (public databases, third-party services)
- **No direct Supabase access** - authorization via MCP/orchestration layer

#### MCP Registration
- Wrap Python tools as MCP servers (stdio or HTTP)
- Load via orchestration layer: `add_mcp(config_path="./mcp_config.yaml")`

---

## Authentication & Payment

### Authentication

#### Email Verification
- Use Supabase built-in email magic link/OTP
- Frontend provides email login interface
- Store Supabase session after completion

#### WeChat Login
- Backend implements WeChat OAuth:
  1. Frontend redirects to WeChat authorization
  2. Backend validates `code` and retrieves `openid/unionid`
  3. Create user if not exists, bind to Supabase
  4. Frontend receives backend-issued JWT/session
- All subsequent MCP requests carry this token

### Payment & Task Metering

#### Payment Channels
- **WeChat Pay + Alipay** integration
- Flow: Create pre-order → Generate QR code/link → Frontend display → Payment callback updates `payments` table
- All payments linked to `user_id`, `agent_run_ids`, or `project_id`

#### Metering & Billing Models

**Unified Task Meter in Orchestration Layer**:
- Records: LLM tokens (prompt/completion), sandbox execution time, external API calls

**Two Billing Modes**:

1. **Outcome-Based Billing**:
   - Fixed price per task template (e.g., "CRISPR design plan")
   - Charge only on successful completion
   - Partial/no charge on failure

2. **Token-Based Billing**:
   - Real-time charging based on token/resource usage
   - Convert to cost via exchange rate
   - Display real-time "estimated/actual cost" in sidebar

#### Micro-Payment Auto-Authorization
- Users can set "micro-payment auto-auth limit" (e.g., ¥50)
- Stored in `users` table
- When estimated cost < remaining limit:
  - Agent auto-creates payment order and charges
  - No user confirmation required
- Exceeding limit triggers frontend confirmation dialog
- Frontend displays:
  - Current auto-auth balance
  - Recent N auto-charge records (clickable for task details)

---

## Implementation Roadmap

### Phase 1: Foundation
1. Create `orchestrator` service (FastAPI/Flask)
2. Implement MCP server exposing current A1 agent
3. Setup Supabase project with base schema
4. Create frontend scaffold with Lovable

### Phase 2: Agent Coordination
1. Implement Swarm-style multi-agent orchestration
2. Add task routing and handoff logic
3. Integrate Python sandbox (Docker-based)
4. Expose sandbox as MCP tool

### Phase 3: Auth & Billing
1. Setup Supabase Auth + email login
2. Implement WeChat OAuth
3. Integrate WeChat Pay + Alipay SDKs
4. Build task metering system
5. Implement outcome-based and token-based billing

### Phase 4: Production Hardening
1. Add monitoring and logging (Sentry, LogRocket)
2. Implement rate limiting and abuse prevention
3. Add backup and disaster recovery
4. Security audit and penetration testing
5. Performance optimization and caching

---

## Technology Stack

### Frontend
- **Framework**: Next.js / React (generated with Lovable)
- **MCP Client**: Custom WebSocket/SSE client
- **UI**: TailwindCSS, shadcn/ui
- **State Management**: Zustand / React Query

### Backend
- **Language**: Python 3.10+
- **Framework**: FastAPI
- **Agent Library**: bioaisaas (existing)
- **MCP Server**: Custom implementation
- **Sandbox**: Docker / firejail
- **Async**: asyncio, websockets

### Database
- **Primary**: Supabase (PostgreSQL 15+)
- **Vector**: pgvector extension
- **Cache**: Redis (optional)

### Infrastructure
- **Deployment**: Docker Compose / Kubernetes
- **CI/CD**: GitHub Actions
- **Monitoring**: Prometheus + Grafana / Sentry
- **Logging**: Loki / CloudWatch

---

## Security Considerations

### Sandbox Security
- Network isolation (whitelist only)
- Filesystem restrictions (no write to system paths)
- Resource limits (CPU, memory, disk, time)
- User code execution in unprivileged containers

### Authentication Security
- JWT tokens with short expiration
- Refresh token rotation
- Rate limiting on auth endpoints
- Prevent enumeration attacks

### Payment Security
- Never store full credit card numbers
- Use payment gateway SDKs (certified PCI-DSS)
- Implement idempotency for payment operations
- Webhook signature verification
- Reconciliation audits

### Data Privacy
- Multi-tenant data isolation (row-level security)
- Encryption at rest and in transit
- GDPR compliance (data export, deletion)
- Audit logging for sensitive operations

---

## Migration from Current Architecture

### Step 1: Parallel Development
- Develop new orchestration layer alongside existing backend
- Create new MCP endpoints without affecting current API

### Step 2: Gradual Frontend Migration
- Build new Agent-First UI pages
- Use feature flags to toggle between old/new UI
- A/B testing with selected users

### Step 3: Data Migration
- Export existing user data
- Import into Supabase with proper schema mapping
- Validate data integrity

### Step 4: Cutover
- Announce maintenance window
- Switch DNS/load balancer to new stack
- Monitor closely for issues
- Keep old stack running for rollback

### Step 5: Cleanup
- Deprecate old endpoints after stable period
- Decommission old infrastructure
- Archive old codebase

---

## Next Steps

For detailed implementation guides, see:
- [Frontend Integration (Agent-First + MCP)](./FRONTEND_INTEGRATION.md)
- [Authentication & Payment Integration](./BILLING_AND_AUTH.md)
- [Backend Orchestration Layer](./docs/backend_orchestration.md)
- [Supabase Schema](./docs/supabase_schema.sql)

---

## Contributing

This production architecture is designed to scale with community contributions. Key areas for contribution:
- New agent tools and capabilities
- Frontend UI/UX improvements
- Performance optimizations
- Security enhancements
- Documentation and examples

See [CONTRIBUTION.md](./CONTRIBUTION.md) for guidelines.

---

## License

BioAiSaaS is Apache 2.0 licensed. See [LICENSE](./LICENSE) for details.
